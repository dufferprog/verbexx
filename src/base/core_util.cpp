// core_util.cpp

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////
//// 
////     =============
////     core_util.cpp -- general, miscellaneous, and utility functions (file-oriented functions moved to ex_core_file.cpp)
////     =============
//// 
//// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "h__include.h"
#pragma hdrstop("../pch/pch_std.pch")

#define M_IN_CORE_DLL

#include "h__common.h"

         
//    static variables 
//    ----------------

namespace static_N
{
    // tracker_C counters

    uint64_t                                tracker_construct       {0};                  // number of times constructor was called
    uint64_t                                tracker_destruct        {0};                  // number of times destructor was called 


    // timepoints and captured performance counters

    std::chrono::steady_clock::time_point   steady_tp1              { };                  // first  saved timepoint              
    std::chrono::steady_clock::time_point   steady_tp2              { };                  // second saved timepoint 
    std::chrono::steady_clock::time_point   steady_tp3              { };                  // third  saved timepoint 

    int64_t                                 pc1                     { -1 };               // first  saved performance counter (probably start of whole run)
    int64_t                                 pc2                     { -1 };               // second saved performance counter (probably start of parse phase) 
    int64_t                                 pc3                     { -1 };               // third  saved performance counter (probably start of evaluation phase)
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    timer-oriented functions
//    ------------------------
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// ----------------------
// set_steady_timepoint()
// ----------------------

M_CORE_IMPEXP
int set_steady_timepoint(uint32_t n) try
{
    switch (n)
    {
        case 1 : 
            static_N::steady_tp1 = std::chrono::steady_clock::now();  
            break; 
    
        case 2 : 
            static_N::steady_tp2 = std::chrono::steady_clock::now();  
            break;

        case 3 :  
            static_N::steady_tp3 = std::chrono::steady_clock::now();  
            break;

        default : 
            M_out_emsg(L"set_steady_timepoint() -- timepoint number (%d) is not in range 1-3") % n;
            return -1; 
            break;
    }

    return 0; 
}
M_endf


// ----------------------
// elapsed_steady_clock()
// ----------------------

M_CORE_IMPEXP
real_T elapsed_steady_time(uint32_t n) try
{
    real_T elapsed { 0.0 };

    switch (n)
    {
        case 1 : 
            elapsed = M_timer_elapsed(static_N::steady_tp1);  
            break; 
    
        case 2 : 
            elapsed = M_timer_elapsed(static_N::steady_tp2);   
            break;

        case 3 : 
            elapsed = M_timer_elapsed(static_N::steady_tp3);  
            break;

        default : 
            M_out_emsg(L"elapsed_steady_time() -- timepoint number (%d) is not in range 1-3") % n;
            return -1.0; 
            break;
    }

    return elapsed; 
}
M_endf




// ---------------------------
// capture_pc_time()
// ---------------------------

M_CORE_IMPEXP
int capture_pc_time(uint32_t n) try
{
    switch (n)
    {
        case 1 : 
            static_N::pc1 = query_performance_counter();  
            break; 
    
        case 2 : 
            static_N::pc2 = query_performance_counter();  
            break;

        case 3 :  
            static_N::pc3 = query_performance_counter();  
            break;

        default : 
            M_out_emsg(L"capture_performance_count() -- count number (%d) is not in range 1-3") % n;
            return -1; 
            break;
    }

    return 0; 
}
M_endf




// -----------------
// elapsed_pc_time()
// -----------------

M_CORE_IMPEXP
float64_T elapsed_pc_time(uint32_t n) try
{
    float64_T elapsed { 0.0 };

    switch (n)
    {
        case 1 : 
            if (static_N::pc1 == -1)
                elapsed = -1.0; 
            else
                elapsed = performance_counter_interval(static_N::pc1);  
            break; 
    
        case 2 : 
            if (static_N::pc2 == -1)
                elapsed = -1.0; 
            else
                elapsed = performance_counter_interval(static_N::pc2); 
            break;

        case 3 : 
            if (static_N::pc3 == -1)
                elapsed = -1.0; 
            else
                elapsed = performance_counter_interval(static_N::pc3); 
            break;

        default : 
            M_out_emsg(L"elapsed_pc_time() -- count number (%d) is not in range 1-3") % n;
            elapsed = -1.0;
            break;
    }

    return elapsed; 
}
M_endf




//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\
//
//           note: template buffer_C functions are in h_core_template.h (template functions needed in all compiles)  
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!//





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////
////
////        ==============================
////        Member functions for tracker_C
////        ==============================
////
////                                                                                             
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// default constructor 
// ------------------- 
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
tracker_C::tracker_C()      
     : lineage       {std::to_wstring(0)}   
{
    static_N::tracker_construct ++; 
	{M_out_lk( L"tracker_C::tracker() called -- default constructor -- id=%d  copy_id=%d  move_id=%d  lineage=\"%s\"  constuct/destruct = %d/%d")
             % id % copy_id % move_id % lineage % static_N::tracker_construct % static_N::tracker_destruct
             ;
    } 
    return;
}


 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// int constructor -- int parm is the ID 
// --------------- 
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
tracker_C::tracker_C(int parm_id)      
     : id            {parm_id                 }   
     , lineage       {std::to_wstring(parm_id)}   
{
    static_N::tracker_construct ++; 
	{M_out_lk( L"tracker_C::tracker(%d) called -- int constructor -- parm_id=%d  id=%d  copy_id=%d  move_id=%d  lineage=\"%s\"  constuct/destruct = %d/%d")
             % parm_id % parm_id % id % copy_id % move_id % lineage % static_N::tracker_construct % static_N::tracker_destruct
             ;
    } 
    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// copy constructor 
// ---------------- 
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
tracker_C::tracker_C(const tracker_C& from)
     : id         {from.id                                 }   
     , copy_id    {from.copy_id + 1                        }
     , move_id    {from.move_id                            }
     , lineage    {from.lineage + std::wstring(L" : Copy") }  
{
    static_N::tracker_construct ++; 
    {M_out_lk(L"tracker_C::tracker(const tracker_C&) called -- copy constructor -- id=%d  copy_id=%d  move_id=%d  lineage=\"%s\"") % id % copy_id % move_id % lineage;}
    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// move constructor 
// ---------------- 
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
tracker_C::tracker_C(tracker_C&& from)
     : id         {from.id         }   
     , copy_id    {from.copy_id    }
     , move_id    {from.move_id + 1}
     , lineage    {from.lineage + std::wstring(L" : Move")}  
{
    static_N::tracker_construct ++; 
	from.lineage += std::wstring(L" : [moved from]");
    {M_out_lk(L"tracker_C::tracker(tracker_C&&) called -- move constructor -- id=%d  copy_id=%d  move_id=%d  lineage=\"%s\"") % id % copy_id % move_id % lineage;}
    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// destructor 
// ----------
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
tracker_C::~tracker_C()                    
{
    static_N::tracker_destruct ++; 
    {M_out_lk(L"tracker_C::~tracker() called -- destructor -- id=%d  copy_id=%d  move_id=%d  lineage=\"%s\"  constuct/destruct = %d/%d") 
             % id % copy_id % move_id % lineage % static_N::tracker_construct % static_N::tracker_destruct
             ;
    }
    return; 
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// copy assignment 
// ---------------
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
tracker_C& tracker_C::operator=(const tracker_C& from)
{
    
         id   = from.id;
    copy_id   = from.copy_id + 1; 
    move_id   = from.move_id;
    lineage   = from.lineage + std::wstring(L" : =Copy=");

    {M_out_lk(L"tracker_C& tracker_C::operator=(const tracker_C&) called -- copy assignment -- id=%d  copy_id=%d  move_id=%d  lineage=\"%s\"") % id % copy_id % move_id % lineage;}
    return *this;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// move assignment 
// ---------------
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
tracker_C& tracker_C::operator=(tracker_C&& from)
{
         id       = from.id;
    copy_id       = from.copy_id; 
    move_id       = from.move_id + 1;
    lineage       = from.lineage + std::wstring(L" : =Move=");
    from.lineage += std::wstring(L" : [=moved= from]");

    {M_out_lk(L"tracker_C& tracker_C::operator=(tracker_C&&) called -- move assignment -- id=%d  copy_id=%d  move_id=%d  lineage=\"%s\"") % id % copy_id % move_id % lineage;}
    return *this;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳║
//║╳╳╳╳╳╳╳╳║
//║╳╳╳╳╳╳╳╳║
//║╳╳╳╳╳╳╳╳║              ================
//║╳╳╳╳╳╳╳╳║              Global Functions -- not connected to any class
//║╳╳╳╳╳╳╳╳║              ================
//║╳╳╳╳╳╳╳╳║
//║╳╳╳╳╳╳╳╳║   
//║╳╳╳╳╳╳╳╳║
//║╳╳╳╳╳╳╳╳║
//║╳╳╳╳╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_wstring() -- convert input std::string to std::wstring -- std::string assumed to have ANSI characters in some code page, not utf8 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// -----------------------------------
// 1st version -- input is std::string
// -----------------------------------

M_CORE_IMPEXP
std::wstring to_wstring(const std::string& s, UINT code_page) try
{
    // return empty output wstring, if input string is empty

    if (s.size() == 0)
        return std::wstring { }; 


    // find out how large the wide string buffer has to be 

    int rc1 =  MultiByteToWideChar( code_page
                                  , 0                    // dword flags
                                  , s.c_str()
                                  , (int)(s.size())  
                                  , nullptr              // not needed for this call
                                  , 0                    // just return size for allocation
                                  );

    M__(M_out("rc from 1st call = %d") % rc1;)

    if (rc1 == 0)       
        M_throw_v("to_wstring(): r/c = 0 from 1st call to MultiByteToWideChar() -- Error code = %d") % (int)GetLastError() )); 


    // allocate buffer and pass it to wide string conversion routine 

    std::unique_ptr<wchar_t[]> wbuf_up(new wchar_t[rc1]);     

    int rc2 =  MultiByteToWideChar( code_page
                                  , 0                    // dword flags
                                  , s.c_str()
                                  , (int)(s.size())  
                                  , wbuf_up.get()        // wide char output buffer
                                  , rc1                  // size from 1st call
                                  );

    M__(M_out(L"rc from 2nd call = %d") % rc2;)

    if (rc2 == 0)  
        M_throw_v("to_wstring(): R/C = 0 from 2nd call to MultiByteToWideChar() -- Error code = %d") % (int)GetLastError() ));  

    if (rc2 != rc1)      // did buffer overflow/underflow occur on 2nd call?
        M_throw_v("to_wstring(): 2nd R/C (%d) from MultiByteToWideChar() larger/smaller than 1st R/C (%d)") % rc2 % rc1 ));
      

    // return wide string

    std::wstring ws(wbuf_up.get(), rc2);
    wbuf_up.reset(); 
    return ws; 
}
M_endf

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ------------------------------
// 2nd version -- input is char *
// ------------------------------

M_CORE_IMPEXP
std::wstring to_wstring(const char *p, UINT code_page) try
{
    // return empty output wstring, if input string is empty

    size_t l = strlen(p);  

    if (l == 0)
        return std::wstring { }; 


    // find out how large the wide string buffer has to be 

    int rc1 =  MultiByteToWideChar( code_page
                                  , 0                    // dword flags
                                  , p
                                  , (int)l  
                                  , nullptr              // not needed for this call
                                  , 0                    // just return size for allocation
                                  );

    M__(M_out(L"rc from 1st call = %d") % rc1;)

    if (rc1 == 0)       
        M_throw_v("to_wstring(): r/c = 0 from 1st call to MultiByteToWideChar() -- Error code = %d") % (int)GetLastError() ));


    // allocate buffer and pass it to wide string conversion routine 

    std::unique_ptr<wchar_t[]> wbuf_up(new wchar_t[rc1]);     

    int rc2 =  MultiByteToWideChar( code_page
                                  , 0                    // dword flags
                                  , p
                                  , (int)l  
                                  , wbuf_up.get()        // wide char output buffer
                                  , rc1                  // size from 1st call
                                  );

     M__(M_out(L"rc from 2nd call = %d") % rc2;)

    if (rc1 == 0)       
        M_throw_v("to_wstring(): r/c = 0 from 2nd call to MultiByteToWideChar() -- Error code = %d") % (int)GetLastError() )); 

    if (rc2 != rc1)      // did buffer overflow/underflow occur on 2nd call?
        M_throw_v("to_wstring(): 2nd R/C (%d) from MultiByteToWideChar() larger/smaller than 1st R/C (%d)") % rc2 % rc1 ));


    // return wide string

    std::wstring ws(wbuf_up.get(), rc2);
    wbuf_up.reset(); 
    return ws; 
}
M_endf



//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_string() -- convert input std::wstring to std::string -- std::wstring assumed to have wide characters (UTF-16)  
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// ------------------------------------
// 1st version -- input is std::wstring
// ------------------------------------

M_CORE_IMPEXP
std::string to_string(const std::wstring& w, UINT code_page) try
{
    // return empty output string, if input wstring is empty

    if (w.size() == 0)
        return std::string { }; 


    // find out how large the string buffer has to be -- first pass 

    int rc1 =  WideCharToMultiByte( code_page            // code page for converted output string
                                  , 0                    // dword flags
                                  , w.c_str()
                                  , (int)(w.size())  
                                  , nullptr              // not needed for this call
                                  , 0                    // just return size for allocation
                                  , NULL                 // use system default substitute char
                                  , NULL                 // don't care if substitute char is used 
                                  );

    M__(M_out("rc from 1st call = %d") % rc1;)

    if (rc1 == 0)       
        M_throw_v("to_string(): r/c = 0 from 1st call to WideCharToMultiByte() -- Error code = %d") % (int)GetLastError() )); 


    // allocate buffer and pass it to wide string conversion routine -- the 2nd pass 

    std::unique_ptr<char[]> buf_up(new char[rc1]);     

    int rc2 =  WideCharToMultiByte( code_page
                                  , 0                    // dword flags
                                  , w.c_str()
                                  , (int)(w.size())  
                                  , buf_up.get()         // char output buffer
                                  , rc1                  // size from 1st call
                                  , NULL                 // use system default substitute char
                                  , NULL                 // don't care if substitute char is used 
                                  );

    M__(M_out(L"rc from 2nd call = %d") % rc2;)

    if (rc2 == 0)  
        M_throw_v("to_string(): R/C = 0 from 2nd call to WideCharToMultiByte() -- Error code = %d") % (int)GetLastError() ));  

    if (rc2 != rc1)      // did buffer overflow/underflow occur on 2nd call?
        M_throw_v("to_string(): 2nd R/C (%d) from WideCharToMultiByte() larger/smaller than 1st R/C (%d)") % rc2 % rc1 ));
      

    // return string

    std::string s(buf_up.get(), rc2);
    buf_up.reset(); 
    return s; 
}
M_endf

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ---------------------------------
// 2nd version -- input is wchar_t *
// ---------------------------------

M_CORE_IMPEXP
std::string to_string(const wchar_t *p, UINT code_page) try
{
    // return empty output wstring, if input string is empty

    size_t l = wcslen(p);    

    if (l == 0)
        return std::string { }; 


    // find out how large the string buffer has to be 

    int rc1 =  WideCharToMultiByte( code_page
                                  , 0                    // dword flags
                                  , p
                                  , (int)l  
                                  , nullptr              // not needed for this call
                                  , 0                    // just return size for allocation
                                  , NULL                 // use system default substitute char
                                  , NULL                 // don't care if substitute char is used 
                                  );

    M__(M_out(L"rc from 1st call = %d") % rc1;)

    if (rc1 == 0)       
        M_throw_v("to_string(): r/c = 0 from 1st call to WideCharToMultiByte() -- Error code = %d") % (int)GetLastError() ));


    // allocate buffer and pass it to wide string conversion routine 

    std::unique_ptr<char[]> buf_up(new char[rc1]);     

    int rc2 =  WideCharToMultiByte( code_page
                                  , 0                    // dword flags
                                  , p
                                  , (int)l  
                                  , buf_up.get()         // wide char output buffer
                                  , rc1                  // size from 1st call
                                  , NULL                 // use system default substitute char
                                  , NULL                 // don't care if substitute char is used 
                                  );

    M__(M_out(L"rc from 2nd call = %d") % rc2;)

    if (rc1 == 0)       
        M_throw_v("to_string(): r/c = 0 from 2nd call to WideCharToMultiByte() -- Error code = %d") % (int)GetLastError() )); 

    if (rc2 != rc1)      // did buffer overflow/underflow occur on 2nd call?
        M_throw_v("to_string(): 2nd R/C (%d) from WideCharToMultiByte() larger/smaller than 1st R/C (%d)") % rc2 % rc1 ));


    // return string

    std::string s (buf_up.get(), rc2);
    buf_up.reset(); 
    return s; 
}
M_endf  






//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_char32() -- convert two wchar_t to char32_t 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_char32(wchar_t wch1, wchar_t wch2, char32_t& ch32, bool check_for_0000) try 
{
    int rc {0};      

    // handle case with leading surrogate and trailing surrogate

    if ( M_is_lead_surrogate(wch1) )                                                                 // 1st wchar_t is a leading surrogate ?
    {
         if ( M_is_trail_surrogate(wch2) )                                                           // 2nd wchar_t is a trailing surrogate ?
         {
             // valid surrogate pair -- extract 10 bits each from leading and trailing surrogate  

             ch32 = const_N::utf16_plane1_base + (  ((((uint32_t)wch1) & const_N::utf16_mask_lo10) << 10) | (((uint32_t)wch2) & const_N::utf16_mask_lo10)  );  
         }
         else                                                                                        // 2nd wchar_t is not a trailing surrogate
         {
             // invalid surrogate pair -- 1st wchar_t is leading surrogate, but 2nd wchar_t is not trailing surrogate 
         
             M_out_note(L"to_char32() -- 1st input wchar_t (%04X) is leading surrogate, but 2nd input wchar_t (%04X) is not trailing surrogate") % (uint16_t)wch1 % (uint16_t)wch2;
             ch32 = 0x00000000U; 
             rc = -1; 
         }  
    }


    // complain if 1st wchar_t is trailing surrogate

    else if ( M_is_trail_surrogate(wch2) )                                                           // 1st wchar_t is a trailing surrogate ?
    {
        M_out_note(L"to_char32() -- 1st input wchar_t (%04X) is trailing surrogate -- (2nd input wchar_t = %04X)") % (uint16_t)wch1 % (uint16_t)wch2;
        ch32 = 0x00000000U;
        rc = -1;
    }


    // handle simple (basic plane) character -- no surrogate pair

    else
    {
        if  (
              (check_for_0000)                                                                       // make sure 2nd char is 0000, if requested 
              &&
              (((uint32_t)wch2) != 0x00000000U)                                                      // 2nd input wchar_t should be 0, if no surrogates
            )
        {
             M_out_note(L"to_char32() -- 1st input wchar_t (%04X) is not leading surrogate, but 2nd input wchar_t (%04X) is not 0") % (uint16_t)wch1 % (uint16_t)wch2;
             rc = -1;
        }

        ch32 = (char32_t)wch1;                                   // output char32_t is just 0x0000 + wch1 
    }

    return rc;     
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_wchars() -- char32_t to two wchar_t 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_wchars(char32_t ch32, wchar_t& wch1, wchar_t& wch2) try
{  
    int rc {0};

    if (
        ( (uint32_t)ch32 > const_N::utf16_max )  
        ||
        (
         ( (uint32_t)ch32 >= const_N::utf16_surrogate_lo) 
         &&
         ( (uint32_t)ch32 <= const_N::utf16_surrogate_hi) 
        )
       )
    {
         M_out_note(L"to_wchars() -- input char32_t (%08X) is not in valid range (0x00000000 to 0x0000D7FF or 0x0000E0000 to 0X0010FFFF)") % (uint32_t)ch32;

         wch1 = (wchar_t)0x0000U;
         wch2 = (wchar_t)0x0000U;
         rc = -1; 
    }    
    else if ( ((uint32_t)ch32) > const_N::utf16_plane0_max )    // not in BMP -- need leading and trailing surrogates 
    {    
        wch1 = (wchar_t)(const_N::utf16_leading_base  +  (((ch32 - const_N::utf16_plane1_base) & const_N::utf16_mask_hi10) >> const_N::utf16_shift10) );         // leading  surrogate = D800 + high 10 bits in (cha32_t - 0x00010000U)  
        wch2 = (wchar_t)(const_N::utf16_trailing_base +  ( (ch32 - const_N::utf16_plane1_base) & const_N::utf16_mask_lo10                           ) );         // trailing surrogate = DC00 + low  10 bits in (cha32_t - 0x00010000U)  
    }
    else                                                        // simple BMP case -- no lead + trailing surrogate
    {
        wch1 = (wchar_t)ch32; 
        wch2 = (wchar_t)0x0000U;  
    }         

    return rc; 
}
M_endf;    




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_int8() -- convert wstring to int8_t -- R/C = -1 if error -- modifies 2nd parm with output value 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_int8(const std::wstring& ws, int8_t& out, int base) try
{
    int32_t  temp1 {0};
    int8_t   temp2 {0}; 
    size_t   idx   {0}; 
    int      rc    {0}; 
    
    try
    {
        temp1 = std::stoi(ws, &idx, base); 

        // check range -- base 10 will be properly signed number - other bases will be unsigned

        if (base != 10)
        {
            if ( (temp1 > M_uint8_max) )  
            {
                temp2 = (int8_t)0; 
                rc    = -1;  
                M_out_emsg(L"to_int8():: literal (%d) is out of int8_t range (%d to %d)") % temp1 % M_int8_min % M_int8_max;
            }
            else
            {
                temp2 = (int8_t)temp1; 
            }
        }
        else
        {
            if ( (temp1 < M_int8_min) || (temp1 > M_int8_max) )  
            {
                temp2 = (int8_t)0; 
                rc    = -1;  
                M_out_emsg(L"to_int8():: literal (%d) is out of int8_t range (%d to %d)") % temp1 % M_int8_min % M_int8_max;
            }
            else
            {
                temp2 = (int8_t)temp1; 
            }
        }
    }
    catch (...)
    {
        M__(M_out(L"to_int8() : catch entered -- ws = \"%s\"") % ws;)
        temp2 = (int8_t)0; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_int8() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp2 = (int8_t)0; 
        rc = -1; 
    }
    
    out = temp2; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_int16() -- convert wstring to int16_t -- R/C = -1 if error -- modifies 2nd parm with output value 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_int16(const std::wstring& ws, int16_t& out, int base) try
{
    int32_t  temp1 {0};
    int16_t  temp2 {0}; 
    size_t   idx   {0}; 
    int      rc    {0}; 
    
    try
    {
        temp1 = std::stoi(ws, &idx, base); 

        // check range -- base 10 will be properly signed number - other bases will be unsigned

        if (base != 10)
        {
            if ( (temp1 > M_uint16_max) )  
            {
                temp2 = (int16_t)0; 
                rc    = -1;  
                M_out_emsg(L"to_int16():: based literal (%d) is out of uint16_t range (0 to %d)") % temp1 %  M_uint16_max;
            }
            else
            {
                temp2 = (int16_t)temp1; 
            }
        }
        else
        { 
            if ( (temp1 < M_int16_min) || (temp1 > M_int16_max) )  
            {
                temp2 = (int16_t)0; 
                rc    = -1;  
                M_out_emsg(L"to_int16():: literal (%d) is out of int16_t range (%d to %d)") % temp1 % M_int16_min % M_int16_max;
            }
            else
            {
                temp2 = (int16_t)temp1; 
            }
        }
    }
    catch (...)
    {
        M__(M_out(L"to_int16() : catch entered -- ws = \"%s\"") % ws;)
        temp2 = (int16_t)0; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_int16() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp2 = (int16_t)0; 
        rc = -1; 
    }
    
    out = temp2; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_int32() -- convert wstring to int32_t -- R/C = -1 if error -- modifies 2nd parm with output value
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_int32(const std::wstring& ws, int32_t& out, int base) try
{
    int32_t  temp  {0};
    size_t   idx   {0}; 
    int      rc    {0}; 
    
    try
    {
        if (base == 10)        // base = 10?  -- can do normal stoi() conversion of decimal integer literal with sign
        {
            temp = std::stoi(ws, &idx, base);
        }
        else                   // not base 10 -- must do unsigned conversion with 32-bit range check
        {
            uint64_t temp1 = (uint64_t)(std::stoul(ws, &idx, base)); 

            if (temp1 > M_uint32_max)  
            {
                temp = (int32_t)0; 
                rc   = -1;  
                M_out_emsg(L"to_int32():: based literal (%d) is out of uint32_t range (0 to %d) ") % temp1 % 0 % M_uint32_max;
            }
            else
            {
                temp = (int32_t)(uint32_t)temp1; 
            } 
        }      
    }
    catch (...)
    {
        M__(M_out(L"to_int32() : catch entered -- ws = \"%s\"") % ws;)
        temp = 0; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_int32() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp = 0; 
        rc = -1; 
    }

    out = temp; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_int64() -- convert wstring to int64_t -- R/C = -1 if error -- modifies 2nd parm with output value
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_int64(const std::wstring& ws, int64_t& out, int base) try
{
    int64_t  temp {0LL};
    size_t   idx  {0}; 
    int      rc   {0}; 
    
    try
    {
        if (base == 10)
            temp = std::stoll(ws, &idx, base); 
        else
            temp = (int64_t)std::stoull(ws, &idx, base); 
    }
    catch (...)
    {
        M__(M_out(L"to_int64() : catch entered -- ws = \"%s\"") % ws;)
        temp = 0LL; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_int64() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp = 0LL; 
        rc = -1; 
    }

    out = temp; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_uint8() -- convert wstring to uint8_t -- R/C = -1 if error -- modifies 2nd parm with output value 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_uint8(const std::wstring& ws, uint8_t& out, int base) try
{
    uint64_t  temp1 { 0 };
    uint8_t   temp2 { 0 }; 
    size_t    idx   { 0 }; 
    int       rc    { 0 }; 
    
    try
    {
        temp1 = (int64_t)(std::stoul(ws, &idx, base)); 

        if (temp1 > M_uint8_max)  
        {
            temp2 = (uint8_t)0; 
            rc    = -1;  
            M_out_emsg(L"to_uint8():: literal (%d) is out of uint8_t range (0 to %d)") % temp1 % M_uint8_max;
        }
        else
        {
            temp2 = (uint8_t)temp1; 
        }
    }
    catch (...)
    {
        M__(M_out(L"to_uint8() : catch entered -- ws = \"%s\"") % ws;)
        temp2 = (uint8_t)0; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_uint8() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp2 = (uint8_t)0; 
        rc = -1; 
    }
    
    out = temp2; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_uint16() -- convert wstring to uint16_t -- R/C = -1 if error -- modifies 2nd parm with output value 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_uint16(const std::wstring& ws, uint16_t& out, int base) try
{
    uint64_t  temp1 { 0 };
    uint16_t  temp2 { 0 }; 
    size_t    idx   { 0 }; 
    int       rc    { 0 }; 
    
    try
    {
        temp1 = (int64_t)(std::stoul(ws, &idx, base)); 

        if (temp1 > M_uint16_max)  
        {
            temp2 = (uint16_t)0; 
            rc    = -1;  
            M_out_emsg(L"to_uint16():: literal (%d) is out of uint16_t range (0 to %d)") % temp1 % M_uint16_max;
        }
        else
        {
            temp2 = (uint16_t)temp1; 
        }
    }
    catch (...)
    {
        M__(M_out(L"to_uint16() : catch entered -- ws = \"%s\"") % ws;)
        temp2 = (uint16_t)0; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_uint16() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp2 = (uint16_t)0; 
        rc = -1; 
    }
    
    out = temp2; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_uint32() -- convert wstring to uint32_t -- R/C = -1 if error -- modifies 2nd parm with output value 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_uint32(const std::wstring& ws, uint32_t& out, int base) try
{
    uint64_t temp1 { 0 };
    uint32_t temp2 { 0 };
    size_t   idx   { 0 }; 
    int      rc    { 0 }; 
    
    try
    {
        temp1 = (uint64_t)(std::stoul(ws, &idx, base)); 

        if (temp1 > M_uint32_max)  
        {
            temp2 = (uint32_t)0; 
            rc    = -1;  
            M_out_emsg(L"to_uint32():: literal (%d) is out of uint32_t range (0 to %d) ") % temp1 % M_uint32_max;
        }
        else
        {
            temp2 = (uint32_t)temp1; 
        }  
    }
    catch (...)
    {
        M__(M_out(L"to_uint32() : catch entered -- ws = \"%s\"") % ws;)
        temp2 = 0U; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_uint32() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp2 = 0U; 
        rc = -1; 
    }

    out = temp2; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_uint64() -- convert wstring to uint64_t -- R/C = -1 if error -- modifies 2nd parm with output value
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_uint64(const std::wstring& ws, uint64_t& out, int base) try
{
    uint64_t temp {0ULL};
    size_t   idx  {0}; 
    int      rc   {0}; 
    
    try
    {
        temp = std::stoull(ws, &idx, base); 
    }
    catch (...)
    {
        M__(M_out(L"to_uint64() : catch entered -- ws = \"%s\"") % ws;)
        temp = 0ULL; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_uint64() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp = 0ULL; 
        rc = -1; 
    }

    out = temp; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_float32() -- convert wstring to float -- R/C = -1 if error -- modifies 2nd parm with output value
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_float32(const std::wstring& ws, float32_T& out) try
{
    float    temp {0.0F};
    size_t   idx  {0}; 
    int      rc   {0}; 
    
    try
    {
        temp = std::stof(ws, &idx); 
    }
    catch (...)
    {
        M__(M_out(L"to_float32() : catch entered -- ws = \"%s\"") % ws;)
        temp = 0.0F; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_float32() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp = 0.0F; 
        rc = -1; 
    }

    out = (float32_T)temp; 
    return rc;  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      to_float64() -- convert wstring to double -- R/C = -1 if error -- modifies 2nd parm with output value
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int to_float64(const std::wstring& ws, float64_T& out) try
{
    double   temp {0.0};
    size_t   idx  {0}; 
    int      rc   {0}; 
    
    try
    {
        temp = std::stod(ws, &idx); 
    }
    catch (...)
    {
        M__(M_out(L"to_float64() : catch entered -- ws = \"%s\"") % ws;)
        temp = 0.0; 
        rc = -1; 
    }
    
    if (idx != ws.size())
    {   
        M__(M_out(L"to_float64() : idx=%llu   ws.size()=%llu -- ws = \"%s\"") % idx % ws.size() % ws;)
        temp = 0.0; 
        rc = -1; 
    }

    out = (float64_T)temp; 
    return rc;  
}
M_endf





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      out_ws() -- get rid of unprintable characters in std::wstring -- used only for narrow strings (like C++ exception .what() )
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║         printable characters are from 32 to 255 only -- Codepage 1252 assumed
//║╳╳╳╳║
//║╳╳╳╳║         others are printed as `xx` `xxxx` or `xxxxxxxx`
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
std::string out_ws(std::wstring ws) try
{
    std::string s {};                                // output string

    for (auto i = 0; i < ws.size(); ++i)
    {
        uint32_t ch = (uint32_t)(ws.at(i)); 
    
        if ( (ch >= 32) && (ch <= 255) )
            s += (char)ch; 
        else if (ch == utf32_N::EURO_SIGN)
            s += (char)0x80;                         // CP 1252 value
        else
        {
            if (ch < 256)
            {
                char buf1[10]; 
                sprintf(buf1, "%02X", ch);
                s += "`";
                s += buf1;             
                s += "`";            
            }
            else if ( ch < 65536)
            {
                char buf2[10]; 
                sprintf(buf2, "%04X", ch);
                s += "`";
                s += buf2;             
                s += "`";              
            }
            else
            {
                char buf3[10]; 
                sprintf(buf3, "%08X", ch);
                s += "`";
                s += buf3;             
                s += "`";            
            }       
        }   
    }

    return s; 
}
M_endf


//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      cleanup_ws() -- get rid of unprintable characters in std::wstring -- used for wide strings
//║╳╳╳╳║
//║╳╳╳╳║      for now, unprintable characters are fro 00-31 -- all others arepassed through 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
std::wstring cleanup_ws(std::wstring ws_in) try
{
    std::wstring ws_out {};                           // output string


    // loop over each wchar_t in input wide string
    // -------------------------------------------

    for (auto i = 0; i < ws_in.size(); ++i)
    {
        wchar_t  wc   = ws_in.at(i);
        uint32_t ch32 = (uint32_t)wc; 
    
        if ( ch32 <= 31 )
            ws_out += (wchar_t)(utf32_N::CENT_SIGN);  // put substitute char (cent sign) in output string 
        else 
            ws_out += wc;                             // put original char in output string
    }

    return ws_out; 
}
M_endf





//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      shorten_str() -- truncate string to 'n' characters for printing - 'n' should be at least 15 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// narrow string version
// ---------------------

M_CORE_IMPEXP
std::string shorten_str(std::string str, size_t parm_maxl) try
{
    std::string s {};                 // output string
    
    size_t maxl = M_max(15, parm_maxl);

    auto sz = str.size();

    if (sz > maxl)   
        s = str.substr(0, maxl / 2UL) + std::string{"\"...\""} + str.substr(sz - maxl / 2UL);  
    else
        s = str;            // already small enough 

    return s; 
}
M_endf


// wide string version
// -------------------

M_CORE_IMPEXP
std::wstring shorten_str(std::wstring ws_parm_in, size_t parm_maxl) try
{
    std::wstring ws_in  { cleanup_ws(ws_parm_in) };                 // cleaned-up in put string
    std::wstring ws_out {                        };                 // output string
    
    size_t maxl = M_max(15, parm_maxl);

    auto sz = ws_in.size();

    if (sz > maxl)   
        ws_out = ws_in.substr(0, maxl / 2UL) + std::wstring{L"\"...\""} + ws_in.substr(sz - maxl / 2UL);  
    else
        ws_out = ws_in;                                            // already small enough 

    return ws_out; 
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════


#define FMT_STR_SIZE_1  1000
#define FMT_STR_SIZE_2  1000000        // any output longer than this will be truncated


//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      fmt_ptr() -- format pointer as XXXXXXXX_XXXXXXXX
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
std::wstring fmt_ptr(const void *p) try
{
    wchar_t buf1[FMT_STR_SIZE_1 + 1] { }; 

    (void)_snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, L"%08X_%08X", M_word1_of(p), M_word0_of(p)); 
    return std::wstring {buf1};  
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      remove_line_end() -- remove   \r   or   \n   or   \r\n   or   \n\r   from end of a char/wchar_t string
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════


// ---------------------------------------------------
// wchar* version -- null-terminated string of wchar_t
// ---------------------------------------------------

M_CORE_IMPEXP
int remove_line_end(wchar_t *p) try
{
    int rc  {0 }; 
    auto len = wcslen(p);  

    // remove \n or \r\n from end of caller's string

    if ( ( len > 0) && (p[len-1] == L'\n') )   
    {
        p[len-1] = 0;                              // replace \n with NULL
        len = wcslen(p);                           // refresh string length
        rc++;                                      // keep track of removals

        if ( (len > 0) && (p[len-1] == L'\r') )
        {
            p[len-1] = 0;                          // replace \r with NULL
            rc++;                                  // keep track of removals   
        }      
    }
    else
    if ( ( len > 0) && (p[len-1] == L'\r') )   
    {
        p[len-1] = 0;                              // replace \r with NULL
        len = wcslen(p);                           // refresh string length
        rc++;                                      // keep track of removals

        if ( (len > 0) && (p[len-1] == L'\n') )
        {
            p[len-1] = 0;                          // replace \n with NULL
            rc++;                                  // keep track of removals   
        }      
    }

    return rc;                                     // return with number of trailing characters removed
}
M_endf


// -----------------------------------------------
// char* version -- null-terminated string of char
// -----------------------------------------------

M_CORE_IMPEXP
int remove_line_end(char *p) try
{
    int rc  {0 }; 
    auto len = strlen(p);  

    // remove \n or \r\n from end of caller's string

    if ( ( len > 0) && (p[len-1] == '\n') )   
    {
        p[len-1] = 0;                              // replace \n with NULL
        len = strlen(p);                           // refresh string length
        rc++;                                      // keep track of removals

        if ( (len > 0) && (p[len-1] == '\r') )
        {
            p[len-1] = 0;                          // replace \r with NULL
            rc++;                                  // keep track of removals   
        }      
    }
    else
    if ( ( len > 0) && (p[len-1] == '\r') )   
    {
        p[len-1] = 0;                              // replace \r with NULL
        len = strlen(p);                           // refresh string length
        rc++;                                      // keep track of removals

        if ( (len > 0) && (p[len-1] == '\n') )
        {
            p[len-1] = 0;                          // replace \n with NULL
            rc++;                                  // keep track of removals   
        }      
    }

    return rc;                                     // return with number of trailing characters removed
}
M_endf


// ---------------------------------------------------------
// std::wstring version 
// ---------------------------------------------------------

M_CORE_IMPEXP
int remove_line_end(std::wstring& s) try
{
    int rc  {0 }; 
    auto len = s.size();   

    // remove \n or \r\n from end of caller's string

    if ( ( len > 0) && (s.back() == L'\n') )   
    {
        s.pop_back();                              // remove \n 
        len = s.size();                            // refresh string length
        rc++;                                      // keep track of removals

        if ( (len > 0) && (s.back() == L'\r') )
        {
            s.pop_back();                          // remove \r
            rc++;                                  // keep track of removals   
        }      
    }
    else
    if ( ( len > 0) && (s.back() == L'\r') )   
    {
        s.pop_back();                              // remove \r 
        len = s.size();                            // refresh string length
        rc++;                                      // keep track of removals

        if ( (len > 0) && (s.back() == L'\n') )
        {
            s.pop_back();                          // remove \n
            rc++;                                  // keep track of removals   
        }      
    }

    return rc;                                     // return with number of trailing characters removed
}
M_endf


 // ---------------------------------------------------------
// std::string version 
// ---------------------------------------------------------

M_CORE_IMPEXP
int remove_line_end(std::string& s) try
{
    int rc  {0 }; 
    auto len = s.size();   

    // remove \n or \r\n from end of caller's string

    if ( ( len > 0) && (s.back() == '\n') )   
    {
        s.pop_back();                              // remove \n 
        len = s.size();                            // refresh string length
        rc++;                                      // keep track of removals

        if ( (len > 0) && (s.back() == '\r') )
        {
            s.pop_back();                          // remove \r
            rc++;                                  // keep track of removals   
        }      
    }
    else
    if ( ( len > 0) && (s.back() == '\r') )   
    {
        s.pop_back();                              // remove \r 
        len = s.size();                            // refresh string length
        rc++;                                      // keep track of removals

        if ( (len > 0) && (s.back() == '\n') )
        {
            s.pop_back();                          // remove \n
            rc++;                                  // keep track of removals   
        }      
    }

    return rc;                                     // return with number of trailing characters removed
}
M_endf




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      fmt_str() -- format output string based on _snwprintf_s() format string and input variable 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════


// -----------------------------------------------------------------------------------------------------------
// to_wstring for unit_T values (no format string) -- substitute for std::to_wstring(), but for unit_T values  
// -----------------------------------------------------------------------------------------------------------

M_CORE_IMPEXP
std::wstring to_wstring(unit_T v) try 
{
    return fmt_str( std::wstring { L"%s" }, v ); 
}
M_endf 


// --------------------------------------------------------------------------------------------------------
// to_wstring() for bool values (no format string) -- substitute for std::to_wstring(), but for bool values  
// --------------------------------------------------------------------------------------------------------

M_CORE_IMPEXP
std::wstring to_wstring(bool v) try 
{
    return fmt_str( std::wstring { L"%s" }, v ); 
}
M_endf    


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// -------------
// unit versions 
// -------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, unit_T v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    std::wstring v_str { L"<UNIT>" };

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), v_str); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), v_str);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf
 

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, unit_T v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    std::wstring v_str { L"<UNIT>" };

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, v_str); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE,fmt.c_str(), i1, v_str);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, unit_T v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    std::wstring v_str { L"<UNIT>" };

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, i2, v_str); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, i2, v_str);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf




// -------------
// bool versions 
// -------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, bool v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    std::wstring v_str { v ? L"<TRUE>" : L"<FALSE>" };

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), v_str); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), v_str);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, bool v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    std::wstring v_str { v ? L"<TRUE>" : L"<FALSE>" };

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, v_str); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, v_str);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, bool v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    std::wstring v_str { v ? L"<TRUE>" : L"<FALSE>" };

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, i2, v_str); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, i2, v_str);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf
 



// ---------------
// int8_t versions 
// ---------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int8_t v) try 
{
    return fmt_str(fmt, (int32_t)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int8_t v) try 
{
    return fmt_str(fmt, i1, (int32_t)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, int8_t v) try 
{
    return fmt_str(fmt, i1, i2, (int32_t)v);
}
M_endf



// ----------------
// int16_t versions 
// ----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int16_t v) try 
{
    return fmt_str(fmt, (int32_t)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int16_t v) try 
{
    return fmt_str(fmt, i1, (int32_t)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, int16_t v) try 
{
    return fmt_str(fmt, i1, i2, (int32_t)v);
}
M_endf


// ----------------
// int32_t versions
// ----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int32_t v) try 
{
    M__(M_out(L"fmt_str(int32_t):  v = %d   fmt=\"%S\"") % v % fmt;)
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), v); 
   
    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int32_t v) try 
{
    M__(M_out(L"fmt_str(int32_t):  v = %d   fmt=\"%S\"") % v % fmt;)
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, v); 
   
    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, int32_t v) try 
{
    M__(M_out(L"fmt_str(int32_t):  v = %d   fmt=\"%S\"") % v % fmt;)
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, i2, v); 
   
    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, i2, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf



// ----------------
// int64_t versions
// ----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int64_t v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int64_t v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf



M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, int64_t v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, i2, v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, i2, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf



// ----------------
// uint8_t versions 
// ----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, uint8_t v) try 
{
    return fmt_str(fmt, (uint32_t)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, uint8_t v) try 
{
    return fmt_str(fmt, i1, (uint32_t)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, uint8_t v) try 
{
    return fmt_str(fmt, i1, i2, (uint32_t)v);
}
M_endf




// -----------------
// uint16_t versions 
// -----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, uint16_t v) try 
{
    return fmt_str(fmt, (uint32_t)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, uint16_t v) try 
{
    return fmt_str(fmt, i1, (uint32_t)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, uint16_t v) try 
{
    return fmt_str(fmt, i1, i2, (uint32_t)v);
}
M_endf




// ----------------
// uint32_t version
// ----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, uint32_t v) try 
{
    M__(M_out(L"fmt_str(uint32_t):  v = %d") % v;)
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, uint32_t v) try 
{
    M__(M_out(L"fmt_str(uint32_t):  v = %d") % v;)
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf
         

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, uint32_t v) try 
{
    M__(M_out(L"fmt_str(uint32_t):  v = %d") % v;)
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, i2, v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, i2, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf




// ----------------
// uint64_t version
// ----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, uint64_t v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, uint64_t v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, uint64_t v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, i2, v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, i2, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf



// -----------------
// float32_T version  
// -----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, float32_T v) try 
{
    return fmt_str(fmt, (float64_T)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, float32_T v) try 
{
    return fmt_str(fmt, i1, (float64_T)v);
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, float32_T v) try 
{
    return fmt_str(fmt, i1, i2, (float64_T)v);
}
M_endf




// ----------------- 
// float64_T version
// -----------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, float64_T v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, float64_T v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, float64_T v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, i2, v); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, i2, v);
        return std::wstring { buf2 };
    }

    return std::wstring { buf1 }; 
}
M_endf




// --------------------
// std::wstring version
//---------------------

M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, const std::wstring& v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), v.c_str()); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), v.c_str());
        return std::wstring { buf2 };
    }
      
    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, const std::wstring& v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, v.c_str()); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, v.c_str());
        return std::wstring { buf2 };
    }
      
    return std::wstring { buf1 }; 
}
M_endf


M_CORE_IMPEXP
std::wstring fmt_str(const std::wstring& fmt, int i1, int i2, const std::wstring& v) try 
{
    wchar_t buf1[FMT_STR_SIZE_1 + 2] { }; 

    auto c = _snwprintf_s(buf1, FMT_STR_SIZE_1, _TRUNCATE, fmt.c_str(), i1, i2, v.c_str()); 

    if (c < 0)
    {
        wchar_t buf2[FMT_STR_SIZE_2 + 2] { };
        (void)_snwprintf_s(buf2, FMT_STR_SIZE_2, _TRUNCATE, fmt.c_str(), i1, i2, v.c_str());
        return std::wstring { buf2 };
    }
      
    return std::wstring { buf1 }; 
}
M_endf







//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      deg_to_dms_string() -- convert real_T degrees into std::wstring with N|E|S|W followed by degrees_minutes_seconds
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
std::wstring deg_to_d_m_s(real_T parm_degree, int32_t direction) try   // direction 1 = N|S prefix   direction = 2 = E|W prefix    0 = no NS|EW prefix
{
    std::wstring s;                // string for returning
    wchar_t buf[20] {};            // buffer for _snwprintf_s 


    // put out N, S, E, W, character and make degrees positive -- direction = 0 -- none, 1 = NS 2 = EW

    real_T degree {parm_degree};

    if (degree >= 0.0)
    {                               // North or East (or nothing)
        if       (direction == 1) 
            s = L"N"; 
        else  if (direction == 2) 
            s = L"E";         
    }
    else                          // South or West (or nothing)
    {
        if      (direction == 1)         
            s += L"S";         
        else if (direction == 2)        
            s += L"W";        

        degree = -degree; 
    }


    // append ddd* mm' ss'' to the 1st letter

    int32_t deg = (int32_t)degree; 
    int32_t min = (int32_t)( degree * 60.0   - (real_T)deg * 60.0                        );
    int32_t sec = M_round(   degree * 3600.0 - (real_T)deg * 3600.0 - (real_T)min * 60.0 );                              

    if (direction == 1) 
        (void)_snwprintf_s(buf, (size_t)36, _TRUNCATE, L"%02d°%02d'%02d''", deg, min, sec);
    else
        (void)_snwprintf_s(buf, (size_t)36, _TRUNCATE, L"%03d°%02d'%02d''", deg, min, sec);
    
    s += buf; 

    return s; 
}
M_endf
 



//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      add_separators_a() -- add thousands separators (ASCII version) -- obsolete
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════


// uint64_t version
// ----------------

M_CORE_IMPEXP
std::string add_separators_a(uint64_t n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
    std::string s = std::to_string(n);
    auto sz = s.size(); 

    if (sz > max_no_sep)
    {
        for (auto i = sz; i >= sep_stride + 1; i -= sep_stride)
            s.insert((std::string::size_type)(i - sep_stride), 1, sep);         
    }

    return s; 
}
M_endf


// int64_t version
// ---------------

M_CORE_IMPEXP
std::string add_separators_a(int64_t n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
    std::string s = std::to_string(n);
    auto sz = s.size(); 

    if (n < 0)
    {
       if (sz > max_no_sep + 1)
       {
           for (auto i = sz; i >= sep_stride + 2; i -= sep_stride)
               s.insert((std::string::size_type)(i - sep_stride), 1, sep);           
       }
    }
    else     // n >= 0
    {
        if (sz > max_no_sep)
        {
            for (auto i = sz; i >= sep_stride + 1; i -= sep_stride)
                s.insert((std::string::size_type)(i - sep_stride), 1, sep);   
        }    
    }

    return s; 
}
M_endf


// float64_T version
// -----------------

M_CORE_IMPEXP
std::string add_separators_a(float64_T n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
    std::string s = std::to_string(n);
    auto pos { s.find_first_of( ".eE" ) };                                                       // look for  '.'  'e'  'f' only -- not locale sensitive
    auto msz { s.size()                 };                                                       // initialize to whole string length, in case none of these are present 

    if (pos != std::string::npos)                                                                // '.'  found? 
       msz = pos;                                                                                // need to limit separator insertion to substring before the  '.' or exponent
    

    if (n < 0.0)
    {
       if (msz > max_no_sep + 1)
       {
           for (auto i = msz; i >= sep_stride + 2; i -= sep_stride)                              // don't put separator right after minus sign (or in front of it) 
               s.insert((std::string::size_type)(i - sep_stride), 1, sep);           
       }
    }
    else     // n >= 0.0
    {
        if (msz > max_no_sep)
        {
            for (auto i = msz; i >= sep_stride + 1; i -= sep_stride)                             // don't put separator in front of 1st digit 
                s.insert((std::string::size_type)(i - sep_stride), 1, sep);   
        }    
    }

    return s; 
}
M_endf
      

/////////////////////////

M_CORE_IMPEXP
std::string add_separators_a(int8_t n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_a((int64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::string add_separators_a(uint8_t n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_a((uint64_t)n, sep, max_no_sep, sep_stride);
}

M_endf


M_CORE_IMPEXP
std::string add_separators_a(int16_t n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_a((int64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::string add_separators_a(uint16_t n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_a((uint64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::string add_separators_a(int32_t n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_a((int64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::string add_separators_a(uint32_t n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_a((uint64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::string add_separators_a(float32_T n, char sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_a((float64_T)n, sep, max_no_sep, sep_stride);
}
M_endf



//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      add_separators_w() -- add thousands separators (Wide Char version) 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════


// uint64_t version
// ----------------

M_CORE_IMPEXP
std::wstring add_separators_w(uint64_t n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{

    std::wstring s = std::to_wstring(n);
    auto sz = s.size();
    M__(M_out(L"add_separators_w(): to_wstring() = \"%s\"") % s;)

    if (sz > max_no_sep)
    {
        for (auto i = sz; i >= sep_stride + 1; i -= sep_stride)                              // don't put separator in front of 1st digit 
            s.insert((std::wstring::size_type)(i - sep_stride), 1, sep);         
    }

    M__(M_out(L"add_separators_w(): returning     --   %s") % s;)
    return s; 
}
M_endf


// int64_t version
// ---------------

M_CORE_IMPEXP
std::wstring add_separators_w(int64_t n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
    std::wstring s = std::to_wstring(n);
    auto sz = s.size(); 

    if (n < 0)
    {
       if (sz > max_no_sep + 1)
       {
           for (auto i = sz; i >= sep_stride + 2; i -= sep_stride)                           // don't put separator right after minus sign (or in front of it) 
               s.insert((std::wstring::size_type)(i - 3), 1, sep);           
       }
    }
    else     // n >= 0
    {
        if (sz > max_no_sep)
        {
            for (auto i = sz; i >= sep_stride + 1; i -= sep_stride)                          // don't put separator in front of 1st digit 
                s.insert((std::wstring::size_type)(i - 3), 1, sep);   
        }    
    }

    return s; 
}
M_endf


// float64_T version
// -----------------

M_CORE_IMPEXP
std::wstring add_separators_w(float64_T n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
    M_y(M_out(L"add_separators_w(float64_T) -- called -- n = \"%f\"") % n ; )

    std::wstring s = std::to_wstring(n);
    auto pos { s.find_first_of( L".eE" ) };                                                      // look for  '.'  'e'  'f' only -- not locale sensitive
    auto msz { s.size()                  };                                                      // initialize to whole string length, in case none of these are  present 

    if (pos != std::string::npos)                                                                // '.'  found? 
       msz = pos;                                                                                // need to limit separator insertion to substring before the  '.'  or exponent
    

    if (n < 0.0)
    {
       if (msz > max_no_sep + 1)
       {
           for (auto i = msz; i >= sep_stride + 2; i -= sep_stride)                              // don't put separator right after minus sign (or in front of it) 
               s.insert((std::wstring::size_type)(i - sep_stride), 1, sep);           
       }
    }
    else     // n >= 0.0
    {
        if (msz > max_no_sep)
        {
            for (auto i = msz; i >= sep_stride + 1; i -= sep_stride)                             // don't put separator in front of 1st digit 
                s.insert((std::wstring::size_type)(i - sep_stride), 1, sep);   
        }    
    }

    M_y(M_out(L"add_separators_w(float64_T) -- return s = \"%S\"") % s ; )
    return s; 
}
M_endf
 


//////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
std::wstring add_separators_w(int32_t n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_w((int64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::wstring add_separators_w(uint32_t n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_w((uint64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::wstring add_separators_w(int16_t n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_w((int64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::wstring add_separators_w(uint16_t n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_w((uint64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::wstring add_separators_w(int8_t n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_w((int64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::wstring add_separators_w(uint8_t n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_w((uint64_t)n, sep, max_no_sep, sep_stride);
}
M_endf


M_CORE_IMPEXP
std::wstring add_separators_w(float32_T n, wchar_t sep, uint32_t max_no_sep, uint32_t sep_stride) try
{
   return add_separators_w((float64_T)n, sep, max_no_sep, sep_stride);
}
M_endf



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//   add_separators_w() -- (decimal) numeric input string version
//   ==================    --------------------------------------
//
//   Numeric input string, perhaps output from _snwprintf_s() is expected to be in one of the following forms:  
//
//
//      "123456789"
//      "-123456789"
//      "+123456789"
//      " 123456789"
//
//      "123456789.1234"
//      "-123456789.1234"
//      "+123456789.1234"
//      " 123456789.1234"
//
//      "123456789.1234e+123"
//      "-123456789.1234e+123"
//      "+123456789.1234e+123"
//      " 123456789.1234e+123"
//
//      "123456789.1234e-123"
//      "-123456789.1234e-123"
//      "+123456789.1234e-123"
//      " 123456789.1234e-123"
//
//      "123456789.1234E+123"
//      "-123456789.1234E+123"
//      "+123456789.1234E+123"
//      " 123456789.1234E+123"
//     
//      "123456789.1234E-123"
//      "-123456789.1234E-123"
//      "+123456789.1234E-123"
//      " 123456789.1234E-123"
//
//      "123456789e+123"
//      "-123456789e+123"
//      "+123456789e+123"
//      " 123456789e+123"
//
//      "123456789e-123"
//      "-123456789e-123"
//      "+123456789e-123"
//      " 123456789e-123"
//
//      "123456789E+123"
//      "-123456789E+123"
//      "+123456789E+123"
//      " 123456789E+123"
//     
//      "123456789E-123"
//      "-123456789E-123"
//      "+123456789E-123"
//      " 123456789E-123"
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
std::wstring add_separators_w(const std::wstring& ws, wchar_t sep, uint32_t parm_max_no_sep, uint32_t parm_sep_stride) try
{
    //M_y(M_out(L"add_separators_w(std::wstring) -- called -- ws = \"%S\"") % ws ; )


    // return immediately, if empty string passed in

    if (ws.size() == 0)
        return ws; 


    // try to delimit the whole-number part of the string that needs separators

    std::wstring s { ws                        };                                                 // local, modifiable copy of input string 
    auto pos       { s.find_first_of( L".eE" ) };                                                 // look for  '.'  'e'  'f' only -- not locale sensitive
    auto msz       { s.size()                  };                                                 // initialize to whole string length, in case none of these are present 

    if (pos != std::string::npos)                                                                 // '.'  found? 
       msz = pos;                                                                                 // need to limit separator insertion to substring before the  '.' or exponent
    
    decltype(msz) sep_stride { parm_sep_stride     };                                             // get separator stride with proper type 
    decltype(msz) sep_stop   { sep_stride + 1      };                                             // need to protect first part of string -- i.e. no separator before 1st numeric chare 
    decltype(msz) max_no_sep { parm_max_no_sep     };                                             // don't add separators unless numeric part of string is longer than this  

    if ( (s.front() == L'-') || (s.front() == L'+') || (s.front() == L' ') )                      // look for one of the expected non-numeric characters at the front:   '-'   '+'   ' '
    {
       max_no_sep++;                                                                              // need to adjust separator insertion threshold to account or the extra (on-numeric) byte at the front 
       sep_stop++;                                                                                // need to prevent separator insertion in front of sign, too
    }

    // insert separators in whole-number numeric part of string
    
    //M_y(M_out(L"add_separators_w(std::wstring) -- msz = %d    max_no_sep = %d") % msz % max_no_sep ; )
    if (msz > max_no_sep)
    {
        //M_y(M_out(L"add_separators_w(std::wstring) -- doing loop") ; )
        for (auto i = msz; i >= sep_stop; i -= sep_stride)                                        // don't put separator in front of 1st digit, etc.
            s.insert(i - sep_stride, 1, sep);   
    }    

    M_y(M_out(L"add_separators_w(std::wstring) -- return s = \"%S\"") % s ; )
    return s; 
}
M_endf





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  




//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║      bigend_xxx() -- convert to/fom big endian and little endian
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP
int16_t bigend_int16(const void *p) try
{
    int16_t int16;
    M_copyswap2_p(&int16, p)    
    return int16; 
}
M_endf


M_CORE_IMPEXP
uint16_t bigend_uint16(const void *p) try
{
    uint16_t uint16;
    M_copyswap2_p(&uint16, p)    
    return uint16; 
}
M_endf


M_CORE_IMPEXP
int32_t bigend_int32(const void *p) try
{
    int32_t int32;
    M_copyswap4_p(&int32, p)    
    return int32; 
}
M_endf


M_CORE_IMPEXP
uint32_t bigend_uint32(const void *p) try
{
    uint32_t uint32;
    M_copyswap4_p(&uint32, p)    
    return uint32; 
}
M_endf


M_CORE_IMPEXP
float32_T bigend_float32( const void *p) try
{
    float32_T float32;
    M_copyswap4_p(&float32, p)    
    return float32; 
}
M_endf           


M_CORE_IMPEXP
float64_T bigend_float64( const void *p) try
{
    float64_T float64;
    M_copyswap8_p(&float64, p)    
    return float64; 
}
M_endf


M_CORE_IMPEXP
real32_T bigend_real32( const void *p) try
{
    real32_T real32;
    M_copyswap4_p(&real32, p)    
    return real32; 
}
M_endf           


M_CORE_IMPEXP
real64_T bigend_real64( const void *p) try
{
    real64_T real64;
    M_copyswap8_p(&real64, p)    
    return real64; 
}
M_endf


  


//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║       ipow() --    base ** exponent     function 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════


////////////////////////////////////////////////////

M_CORE_IMPEXP
int8_t ipow(int8_t base, int8_t exponent) try
{
    if (exponent < 0)
        return 0; 

    if (exponent == 0)
        return 1; 

    // standard method for integer powers --  (may overflow or wrap around, etc.)

    int8_t result = 1;
    int8_t base2n = base;
    int8_t exp2n  = exponent; 

    while (exp2n > 0)
    {
        if ( (exp2n % 2) == 1 )     // exponent odd ? 
            result *= base2n; 
         
        base2n *= base2n;           // base     * 2^n              
        exp2n  /= 2;                // exponent / 2^n                 
    }

    return result; 
}
M_endf


////////////////////////////////////////////////////

M_CORE_IMPEXP
int16_t ipow(int16_t base, int16_t exponent) try
{
    if (exponent < 0)
        return 0; 

    if (exponent == 0)
        return 1; 

    // standard method for integer powers --  (may overflow or wrap around, etc.)

    int16_t result = 1;
    int16_t base2n = base;
    int16_t exp2n  = exponent; 

    while (exp2n > 0)
    {
        if ( (exp2n % 2) == 1 )     // exponent odd ? 
            result *= base2n; 
         
        base2n *= base2n;           // base     * 2^n              
        exp2n  /= 2;                // exponent / 2^n                 
    }

    return result; 
}
M_endf


////////////////////////////////////////////////////

M_CORE_IMPEXP
int32_t ipow(int32_t base, int32_t exponent) try
{
    if (exponent < 0)
        return 0; 

    if (exponent == 0)
        return 1; 

    // standard method for integer powers --  (may overflow or wrap around, etc.)

    int32_t result = 1;
    int32_t base2n = base;
    int32_t exp2n  = exponent; 

    while (exp2n > 0)
    {
        if ( (exp2n % 2) == 1 )     // exponent odd ? 
            result *= base2n; 
         
        base2n *= base2n;           // base     * 2^n              
        exp2n  /= 2;                // exponent / 2^n                 
    }

    return result; 
}
M_endf


////////////////////////////////////////////////////

M_CORE_IMPEXP
int64_t ipow(int64_t base, int64_t exponent) try
{
    if (exponent < 0)
        return 0; 

    if (exponent == 0)
        return 1; 

    // standard method for integer powers --  (may overflow or wrap around, etc.)

    int64_t result = 1;
    int64_t base2n = base;
    int64_t exp2n  = exponent; 

    while (exp2n > 0)
    {
        if ( (exp2n % 2) == 1 )     // exponent odd ? 
            result *= base2n; 
         
        base2n *= base2n;           // base     * 2^n              
        exp2n  /= 2;                // exponent / 2^n                 
    }

    return result; 
}
M_endf


////////////////////////////////////////

M_CORE_IMPEXP
uint8_t ipow(uint8_t base, uint8_t exponent) try
{
    if (exponent == 0)
        return 1; 

    // standard method for integer powers --  (may overflow or wrap around, etc.)

    uint8_t result = 1;
    uint8_t base2n = base;
    uint8_t exp2n  = exponent; 

    while (exp2n > 0)
    {
        if ( (exp2n % 2) == 1 )     // exponent odd ? 
            result *= base2n; 
         
        base2n *= base2n;           // base     * 2^n              
        exp2n  /= 2;                // exponent / 2^n                 
    }

    return result; 
}
M_endf


////////////////////////////////////////

M_CORE_IMPEXP
uint16_t ipow(uint16_t base, uint16_t exponent) try
{
    if (exponent == 0)
        return 1; 

    // standard method for integer powers --  (may overflow or wrap around, etc.)

    uint16_t result = 1;
    uint16_t base2n = base;
    uint16_t exp2n  = exponent; 

    while (exp2n > 0)
    {
        if ( (exp2n % 2) == 1 )     // exponent odd ? 
            result *= base2n; 
         
        base2n *= base2n;           // base     * 2^n              
        exp2n  /= 2;                // exponent / 2^n                 
    }

    return result; 
}
M_endf



////////////////////////////////////////

M_CORE_IMPEXP
uint32_t ipow(uint32_t base, uint32_t exponent) try
{
    if (exponent == 0)
        return 1; 

    // standard method for integer powers --  (may overflow or wrap around, etc.)

    uint32_t result = 1;
    uint32_t base2n = base;
    uint32_t exp2n  = exponent; 

    while (exp2n > 0)
    {
        if ( (exp2n % 2) == 1 )     // exponent odd ? 
            result *= base2n; 
         
        base2n *= base2n;           // base     * 2^n              
        exp2n  /= 2;                // exponent / 2^n                 
    }

    return result; 
}
M_endf


////////////////////////////////////////////////////////////////

M_CORE_IMPEXP
uint64_t ipow(uint64_t base, uint64_t exponent) try
{
    if (exponent == 0)
        return 1; 

    // standard method for integer powers --  (may overflow or wrap around, etc.)

    uint64_t result = 1;
    uint64_t base2n = base;
    uint64_t exp2n  = exponent; 

    while (exp2n > 0)
    {
        if ( (exp2n % 2) == 1 )     // exponent odd ? 
            result *= base2n; 
         
        base2n *= base2n;           // base     * 2^n              
        exp2n  /= 2;                // exponent / 2^n                 
    }

    return result; 
}
M_endf





//╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳║       power() --    overloaded functions to call ipow() or std::pow() 
//║╳╳╳╳║
//║╳╳╳╳║
//║╳╳╳╳╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//║╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳╳
//╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

M_CORE_IMPEXP      int8_t power(   int8_t base   ,    int8_t exponent    ) {return     ipow(base, exponent);} 
M_CORE_IMPEXP     int16_t power(  int16_t base   ,   int16_t exponent    ) {return     ipow(base, exponent);}
M_CORE_IMPEXP     int32_t power(  int32_t base   ,   int32_t exponent    ) {return     ipow(base, exponent);}
M_CORE_IMPEXP     int64_t power(  int64_t base   ,   int64_t exponent    ) {return     ipow(base, exponent);}
M_CORE_IMPEXP     uint8_t power(  uint8_t base   ,   uint8_t exponent    ) {return     ipow(base, exponent);}
M_CORE_IMPEXP    uint16_t power( uint16_t base   ,  uint16_t exponent    ) {return     ipow(base, exponent);}
M_CORE_IMPEXP    uint32_t power( uint32_t base   ,  uint32_t exponent    ) {return     ipow(base, exponent);}
M_CORE_IMPEXP    uint64_t power( uint64_t base   ,  uint64_t exponent    ) {return     ipow(base, exponent);}
M_CORE_IMPEXP   float32_T power(float32_T base   , float32_T exponent    ) {return std::pow(base, exponent);} 
M_CORE_IMPEXP   float64_T power(float64_T base   , float64_T exponent    ) {return std::pow(base, exponent);} 





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
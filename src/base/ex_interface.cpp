// ex_interface.cpp

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////
//// 
////     ================
////     ex_interface.cpp -- public interfaces to input stream parsing functions
////     ================
////
////
////
////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "h__include.h"
#pragma hdrstop("../pch/pch_std.pch")

#define M_IN_EX_DLL

#include "h__common.h"

#include "h_ex_interface.h"
#include "h_ex_lex.h"
#include "h_ex_parse.h"
#include "h_ex_verb.h"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



// ----------------------
// local static variables
// ----------------------

namespace static_N
{
static std::shared_ptr<frame_S>               pp_frame_sp      {     };     // owning pointer to top-level/persistent  stack frame  
static frame_S                               *main_frame_p     {     };     // non-owning pointer to global/top-level stack frame for evaluation phase 
static environ_S                              environ_global   {     };     // default (static) global environ_S -- global verbs and variables  
static uint64_t                               error_ct         {0    };     // global parser and evaluation error counter (does not include preprocess errors)
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   get_pp_frame() -- pass back shared_ptr to main PP frame_S  
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
std::shared_ptr<frame_S>  get_pp_frame() try
{
     M__(M_out(L"get_pp_frame() -- called -- pp_frame_p = %p") % static_N::pp_frame_sp.get();)


     // allocate new main/static PP frame_S, if none is currently allocated 

     if (static_N::pp_frame_sp.get() == nullptr)
     {
         static_N::pp_frame_sp = new_frame();                                                  // allocate new pp stack frame -- will not be on stack for now, until  becomes active 

         static_N::pp_frame_sp->no_scope                 = true;                               // no access to current active function's (or main SF) variables
         static_N::pp_frame_sp->scope_sp.reset();                                              // no upward scope pointer from here (only the global scope)     
         static_N::pp_frame_sp->is_preprocess            = true;                               // indicate this is a preprocessor stack frame  
         static_N::pp_frame_sp->environ_p->is_preprocess = true;                               // also flag new environment as PP
         static_N::pp_frame_sp->persist_sf_p             = nullptr;                            // no associated persistent SF for the main PP SF
         static_N::pp_frame_sp->verbmain_sf_p            = nullptr;                            // no associated verb main  SF for the main PP SF
         static_N::pp_frame_sp->env.is_preprocess        = true;                               // also flag imbedded environment as preprocessor environment        
     }


     // pass back shared pointer

     return static_N::pp_frame_sp; 
}
M_endf

 



////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   get_main_frame() -- pass back address of main (static, topmost) frame_S  
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
frame_S *get_main_frame() try
{
     M__(M_out(L"get_main_frame() -- called -- main_frame_p = %p") % static_N::main_frame_p;)


     // allocate new frame_S, if none is currently allocated 

     if (static_N::main_frame_p == nullptr)
     {
         static_N::main_frame_p = add_new_frame();                         // allocate new main stack frame -- will be only one on stack, for now

         static_N::main_frame_p->is_main     = true;                       // mark this SF as main
         static_N::main_frame_p->env.is_main = true;                       // mark imbedded envronment as main, too 
     }


     // pass back address, as requested

     return static_N::main_frame_p; 
}
M_endf



////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   setup_global_environ() -- pass back address of global (static) environ_S, after preparing it for use 
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
void setup_global_environ() try
{
    static_N::environ_global.is_global = true;          // indicate that this is global environment
    return; 
}
M_endf






////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   get_global_environ() -- pass back address of global (static) environ_S  (must have been set up already)
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
environ_S *get_global_environ() try
{
    return &(static_N::environ_global); 
}
M_endf






////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   process_main_ext() -- call process_main_file() with main (static) stack frame -- main input only 
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
int process_main_ext(const std::wstring& main_pathname) try
{
    return process_main_file(*(static_N::main_frame_p), main_pathname); 
}
M_endf



////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   process_cmdline_ext() -- call process_cmdline() with default static variables -- stub for external callers  
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
std::wstring process_cmdline_ext(int argc, wchar_t *argv[]) try
{
     return process_cmdline(*get_main_frame(), static_N::environ_global, argc, argv); 
}
M_endf




////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   import_dll() -- load DLL and call do_import(prefix-parm) function in DLL 
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP
int import_dll(const std::wstring& dll_name, const std::wstring& prefix) try
{
    HMODULE      hmodule   { nullptr };
    void        *fcn_p     { nullptr };    


    // load DLL -- load_dll() should put out any needed error messages

    auto ldrc = load_dll(dll_name, hmodule);  
    if (ldrc != 0) return ldrc; 


    // locate do_import() function in loaded DLL-- get_dll_function() should put out any needed error messages

    auto gfrc = get_dll_function(hmodule, std::wstring { L"do_import" }, fcn_p);
    if (gfrc != 0) return gfrc;


    // call located do_import() function in loaded DLL, and return with R/C from that function call

    return (*(do_import_T)fcn_p)(prefix); 
}
M_endf



////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   set_skip_ext() -- set up skip mode ant label in newest pre)parse_C -- stub for external callers  
////                     (note: preprocessor must be active) 
//// 
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
int set_skip_ext(const std::wstring& to_label) try
{
    // make sure current-level pre_process_C instance exists - return with error, if not

     pre_process_C *pp_p = current_pp(); 
     if (pp_p == nullptr)
         return -1; 


     // add passed-in filename to the pending attach stack for current pp instance

     pp_p->set_skip(to_label); 
     return 0; 
}
M_endf



////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   pending_attach_file_ext()    -- set up pending attach for passed-in filename -- stub for external callers  
////   pending_attach_string_ext()  -- set up pending attach for passed-in string   -- stub for external callers    
////
////                                (note: preprocessor must be active) 
//// 
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

// file version -- 1 parm
// ----------------------

M_EX_IMPEXP 
int pending_attach_file_ext(const std::wstring& pathname) try
{
    // make sure current-level pre_process_C instance exists - return with error, if not

     pre_process_C *pp_p = current_pp(); 
     if (pp_p == nullptr)
         return -1; 


     // add passed-in filename to the pending attach stack for current pp instance

     pp_p->add_pending_attach_file(pathname); 
     return 0; 
}
M_endf
 

// string version -- 2 parms
// -------------------------

M_EX_IMPEXP 
int pending_attach_string_ext(const std::wstring& text, const std::wstring& id) try
{
    // make sure current-level pre_process_C instance exists - return with error, if not

     pre_process_C *pp_p = current_pp(); 
     if (pp_p == nullptr)
         return -1; 


     // add passed-in filename to the pending attach stack for current pp instance

     pp_p->add_pending_attach_string(text, id); 
     return 0; 
}
M_endf

 


////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   count_error() -- increment local static error counter 
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
void count_error(uint64_t incr) try
{
    static_N::error_ct += incr; 
    return; 
}
M_endf



////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   error_count() -- return combined number errors
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
uint64_t error_count() try
{
    return static_N::error_ct; 
}
M_endf


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   set_type_value() -- external interface to type_val()  
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
value_S set_type_value(int64_t v) try
{
    return type_val(v); 
}
M_endf


M_EX_IMPEXP 
value_S set_type_value(float64_T v) try
{
    return type_val(v); 
}
M_endf


M_EX_IMPEXP 
value_S set_type_value(const std::wstring& v) try
{
    return type_val(v); 
}
M_endf


////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   add_predefined_verb() -- add pre-defined verb to global environment  
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
int add_predefined_verb(const std::wstring& verb_name, const verbset_S& verbset_in) try
{
    // indicate that verbset_S has at least one built-in verb 

    verbset_S verbset { verbset_in };                                     // local (nodifiable) copy of passed-in verbset
    verbset.has_builtin = true;                                           // indicate that this verbset has at least one predefined verbdef_S 


    // see if any custom evaluation is required -- recursive look into all positional/keyword parms to see if any evaluation flags are already set
    // -------------------------------------------------------------------------------------------------------------------------------------------
    //
    // note: This is bypassed, if the custom_eval flag is already set 

    if (!verbset.custom_eval)
    {
    // ?????? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
    // ?????? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?      need new check_custom_eval() function that can be called recursively for each nested plist pointed to by a parmtype
    // ?????? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
    // ?????? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
    // ?????? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
    }


    // error, if custom evaluation flag (was already/is now) on, and more than one verbdef in the verbset
    // --------------------------------------------------------------------------------------------------

    if ( (verbset.custom_eval) && (verbset.verbs.size() > 1) )
    {
        count_error(); 
        M_out_emsg(L"add_predefined_verb() -- custom evaluation is required for verb \"%S\", but there are %d verbs in the built-in overload set being added -- verbs with custom evaluation cannot be overloaded")  % verb_name % verbset.verbs.size();     
        return -1;  
    }
     

    // if custom evaluation flag is off in the verbset_S, update the evaluation flags each verbdef_S in the passed-in verbset_S, so they are all the same (which allows overloading)
    // --------------------------------------------------------------------------------------------------------------------------------------------------
    //
    // note: does not look into each positional parm nested vlist, nor does it process keyword parms -- these need custom evaluation)

    if (!verbset.custom_eval)
    {
        for (auto& verbdef : verbset.verbs )
        {
            // propagate global plist-wide evaluation flags from verbset_S into the plist-wide evaluation flags in the left and right-side parmlists in this verbdef  
      
            verbdef.lparms.eval.no_eval_ident         |=  verbset. left_eval.no_eval_ident      ;
            verbdef.lparms.eval.no_eval_expression    |=  verbset. left_eval.no_eval_expression ;
            verbdef.lparms.eval.no_eval_vlist         |=  verbset. left_eval.no_eval_vlist      ;
            verbdef.lparms.eval.no_eval_ref           |=  verbset. left_eval.no_eval_ref        ;
            verbdef.rparms.eval.no_eval_ident         |=  verbset.right_eval.no_eval_ident      ;
            verbdef.rparms.eval.no_eval_expression    |=  verbset.right_eval.no_eval_expression ;
            verbdef.rparms.eval.no_eval_vlist         |=  verbset.right_eval.no_eval_vlist      ;
            verbdef.rparms.eval.no_eval_ref           |=  verbset.right_eval.no_eval_ref        ;
            
      
            // propagate global plist-wide evaluation flags from verbset_S into each left-side positional parameter parmtype_S   (note: keyword parms are not modified -- these require the "custom_eval" flag)
      
            for (auto& parmtype : verbdef.lparms.values) 
            {
                parmtype.eval.no_eval_ident           |=   verbset.left_eval.no_eval_ident      ;
                parmtype.eval.no_eval_expression      |=   verbset.left_eval.no_eval_expression ;
                parmtype.eval.no_eval_vlist           |=   verbset.left_eval.no_eval_vlist      ;
                parmtype.eval.no_eval_ref             |=   verbset.left_eval.no_eval_ref        ;  
            }
      
      
            // propagate global plist-wide evaluation flags from verbset_S into each right-side positional parameter parmtype_S  (note: keyword parms are not modified -- these require the "custom_eval" flag)
      
            for (auto& parmtype : verbdef.rparms.values) 
            {
                parmtype.eval.no_eval_ident           |=   verbset.right_eval.no_eval_ident      ;
                parmtype.eval.no_eval_expression      |=   verbset.right_eval.no_eval_expression ;
                parmtype.eval.no_eval_vlist           |=   verbset.right_eval.no_eval_vlist      ;
                parmtype.eval.no_eval_ref             |=   verbset.right_eval.no_eval_ref        ;  
            }  
        } 
    }


    // add built-in verbset_S to the global environment
    // ------------------------------------------------

    for (auto& verbdef : verbset.verbs )
        verbdef.is_builtin = true;              // make sure "built-in flag is set in each verbdef_S
                                                                                          
    def_parm_S parm { }; 
    parm.builtin = true; 

    return def_global_verb(verb_name, verbset, parm); 
}
M_endf



////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   attach_plist() -- adds new nested plist_S structure to passed-in parmtype_S (input plist_S is copied into a new one) 
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
int attach_plist(parmtype_S& parmtype, const plist_S& plist) try
{
    // allocate new non-autodata plist_S on heap, anchor in caller's parmtype_S, and copy passed-in plist_S into new plist_S 

    parmtype.plist_sp.reset(new plist_S {}); 
    *parmtype.plist_sp = plist;
    return 0; 
}
M_endf



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
//▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   is_valid_identifier() -- checks input string to see if it's a valid identifier 
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
bool is_valid_identifier(const std::wstring& ws) try
{
    auto sz = ws.size(); 

    M__(M_out(L"is_valid_identifier():  called -- ws = \"%S\" sz = %d" ) % ws % sz);


    // return false, if no characters in string
    // ----------------------------------------
    
    if (sz <= 0)
        return false; 


    // main loop to look at each char32_t in std:wstring (may be surrogate pair in string)
    // -----------------------------------------------------------------------------------

    uint64_t ws_ix      { 0    }; 
    bool     first_ch32 { true };                              // indicate that we haven't seen 1st character yet

             
    while (ws_ix < sz)
    {
        // get next wchar_t from ws -- might be lead surrogate

        wchar_t   wch1  { ws.at(ws_ix++) }; 
        wchar_t   wch2  { 0x0000         }; 
  
        M__(M_out(L"is_valid_identifier():  in loop -- wch1 = %04X" ) % (int)wch1;) 


        // get trailing surrogate, if not at end of string

        if ( M_is_lead_surrogate(wch1) )
        {
            if (ws_ix < sz)
                wch2 = ws.at(ws_ix++);   
            else                           
                return false;              // error -- lead surrogate was last char in string (i.e. missing the trail surrogate)       
        }

        M__(M_out(L"is_valid_identifier():  in loop -- wch1 = %04X   wch2 = %04X" ) % (int)wch1 % (int)wch2;) 


        // convert this wchar_t (or surrogate pair) to char32_t and get char type 

        char32_t ch32 { };
        auto trc = to_char32(wch1, wch2, ch32); 
        if (trc != 0)
            return false;                 // error converting wchars to char32_t
    
        M__(M_out(L"is_valid_identifier():  in loop -- ch32 = %08X" ) % (uint32_t)ch32;)
        auto type = char_type(ch32); 
        M__(M_out(L"is_valid_identifier():  in loop -- type = %d  (sep=%d  alpha=%d  num=%d)") % (int)type % (int)(char_E::sep) % (int)(char_E::alpha) % (int)(char_E::num);)


        // handle first character -or- other characters in identifier

        if (first_ch32)
        {
            // first character can be underscore or alpha (not numeric)

            if (
                (type != char_E::sep  )
                &&
                (type != char_E::alpha)
               )
            {
                M__(M_out(L"is_valid_identifier():  1st char bad" );)
                return false;             // error -- 1st char not underscore or alpha  
            }

            first_ch32 = false;           // 1st char is now processed
        }
        else                              // not 1st char in identifier
        {
            // other characters can be underscore, alpha, or numeric
            
            if (
                (type != char_E::sep  )
                &&
                (type != char_E::alpha)
                &&
                (type != char_E::num  )
               )
            {
                M__(M_out(L"is_valid_identifier():  other char bad" );)
                return false;             // error -- 1st char not underscore or alpha or numeric 
            }         
        }      
    }                                    // end of while loop
    

    // must be good, if no error found yet when loop ended

    M__(M_out(L"is_valid_identifier():  good" );)
    return true; 
}
M_endf


////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   is_valid_operator() -- checks input string to see if it's a valid operator 
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
bool is_valid_operator(const std::wstring& ws) try
{
    auto sz = ws.size(); 

    M__(M_out(L"is_valid_operator():  called -- ws = \"%S\" sz = %d" ) % ws % sz);


    // return false, if no characters in string
    // ----------------------------------------
    
    if (sz <= 0)
        return false; 


    // main loop to look at each char32_t in std:wstring (may be surrogate pair in string)
    // -----------------------------------------------------------------------------------

    uint64_t ws_ix      { 0    }; 
             
    while (ws_ix < sz)
    {
        // get next wchar_t from ws -- might be lead surrogate

        wchar_t   wch1  { ws.at(ws_ix++) }; 
        wchar_t   wch2  { 0x0000         }; 
  
        M__(M_out(L"is_valid_operator():  in loop -- wch1 = %04X" ) % (int)wch1;) 


        // get trailing surrogate, if not at end of string

        if ( M_is_lead_surrogate(wch1) )
        {
            if (ws_ix < sz)
                wch2 = ws.at(ws_ix++);   
            else                           
                return false;              // error -- lead surrogate was last char in string (i.e. missing the trail surrogate)       
        }

        M__(M_out(L"is_valid_is_valid_operator():  in loop -- wch1 = %04X   wch2 = %04X" ) % (int)wch1 % (int)wch2;) 


        // convert this wchar_t (or surrogate pair) to char32_t and get char type 

        char32_t ch32 { };
        auto trc = to_char32(wch1, wch2, ch32); 
        if (trc != 0)
            return false;                 // error converting wchars to char32_t
    
        M__(M_out(L"is_valid_operator():  in loop -- ch32 = %08X" ) % (uint32_t)ch32;)
        auto type = char_type(ch32); 
        M__(M_out(L"is_valid_operator():  in loop -- type = %d  (oper=%d)") % (int)type % (int)(char_E::oper);)


        // handle characters in operator -- all must be type = oper

        if (type != char_E::oper)
        {
             M__(M_out(L"is_valid_operator(): char bad" );)
             return false;               // error -- 1st char not underscore or alpha  
        }
     }                                  // end of while loop
    

    // must be good, if no error found yet when loop ended

    M__(M_out(L"is_valid_operator():  good" );)
    return true; 
}
M_endf


////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
////
////
////   is_valid_verbname() -- checks input string to see if it's a valid verb name
////                   
////
////_____________________________________________________________________________________________________________________
////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
/////\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
////"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

M_EX_IMPEXP 
bool is_valid_verbname(const std::wstring& ws) try
{
    if ( is_valid_identifier(ws) || is_valid_operator(ws) )
        return true;
    else
        return false;   
}
M_endf    




//_________________________________________________________________________________________________________________________________________________________________
//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
//"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
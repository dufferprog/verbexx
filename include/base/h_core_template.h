// h_core_template.h

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////
////
////            ================= 
////            h_core_template.h -- define template items in Buffer_C, so all compiles have the source code available  
////            =================
////     
////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once
#include "h__types.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////
////////
////////
////////
////////    ============
////////    Buffer Class -- template functions that need to be included in util.h
////////    ============
////////
////////
////////
////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// default constructor is defaulted




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    copy constructor
//    ---------------- 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
buffer_C<T>::buffer_C(const buffer_C<T>& from)
    : p              { nullptr          }  
    , sz             { from.sz          } 
    , sz1            { from.sz1         }
    , copy_ct        { from.copy_ct + 1U} 
{
#ifdef M_OUT_WIDE
    M__(M_out(L"<<COPY>> <<COPY>> <<COPY>> <<COPY>> <<COPY>> <<COPY>> <<COPY>> <<COPY>> buffer_C(const buffer_C&) called -- copy constructor -- sz=%s  sz1=%s  copy_ct=%u\"") % M_sep(sz) % M_sep(sz1) % copy_ct;)
#else
    M__(M_out( "<<COPY>> <<COPY>> <<COPY>> <<COPY>> <<COPY>> <<COPY>> <<COPY>> <<COPY>> buffer_C(const buffer_C&) called -- copy constructor -- sz=%s  sz1=%s  copy_ct=%u\"") % M_sep(sz) % M_sep(sz1) % copy_ct;)
#endif

    if (sz1 > 0)
    {
       this->alloc1(sz1);
       memcpy((void *)p1, (void *)(from.p1), (size_t)sz1);
    }

    return;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    move constructor
//    ---------------- 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
buffer_C<T>::buffer_C(buffer_C<T>&& from)
    : p              { from.p         } 
    , p1             { from.p1        }
    , sz             { from.sz        } 
    , sz1            { from.sz1       } 
    , copy_ct        { from.copy_ct   } 
{
#ifdef M_OUT_WIDE
    M__(M_out(L"<<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> buffer_C(buffer_C&&) called -- move constructor -- sz=%s  sz1=%s copy_ct=%u\"") % M_sep(sz) % M_sep(sz1) % copy_ct;)
#else
    M__(M_out( "<<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> <<MOVE>> buffer_C(buffer_C&&) called -- move constructor -- sz=%s  sz1=%s copy_ct=%u\"") % M_sep(sz) % M_sep(sz1) % copy_ct;)
#endif

    from.sz  = 0ULL;              // data area in from has been moved out 
    from.sz1 = 0ULL;              // data area in from has been moved out 
    from.p   = nullptr;           // data area is now anchored off this
    from.p1  = nullptr; 

    return;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  uint64_t constructor -- allocate buffer with size "sz" -- in units of <T>
//  --------------------  
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
buffer_C<T>::buffer_C(uint64_t sz)      
//  : p      {nullptr}                 // defaulted in class declaration -- need to zero these first before callin alloc() below
//  : p1     {nullptr}                 // defaulted in class declaration -- need to zero these first before callin alloc() below
//  , sz     {0ULL} 
{
    M__(M_out(L"buffer_C(%s) called -- constructor") % M_sep(sz);)
    
    this->alloc(sz);
    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  copy assignment -- copy contents of one buffer to another
//  ---------------  
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
buffer_C<T>& buffer_C<T>::operator=(const buffer_C<T>& from)
{
#ifdef M_OUT_WIDE
    M__(M_out(L"<< =COPY= >> << =COPY= >>  buffer_C& operator=(const buffer_C&) called -- copy assignment -- sz=%s  sz1=%s  copy_ct=%u\"") % M_sep(sz) % M_sep(sz1) % copy_ct;)
#else
    M__(M_out( "<< =COPY= >> << =COPY= >>  buffer_C& operator=(const buffer_C&) called -- copy assignment -- sz=%s  sz1=%s  copy_ct=%u\"") % M_sep(sz) % M_sep(sz1) % copy_ct;)
#endif

    //  return immediately, if self-assignment

    if (this == &from)
        return *this;    


    // copy data (if any) from from to this

    this->alloc1(from.sz1);                                     // get rid of current buffer and replace with one large enough to hold data to be copied  -- should set p, p1, sz, sz1 member fields

    if (sz1 > 0)                                                // sz1 should be same as from.sz1 -- p, p1 should not be nullptr if sz/sz1 > 0 
        memcpy((void *)p1, (void *)(from.p1), (size_t)sz1);
    
    return *this; 
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  move assignment -- move contents of one buffer to another ("from" buffer ends up empty)
//  ---------------  
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
buffer_C<T>& buffer_C<T>::operator=(buffer_C<T>&& from)
{
#ifdef M_OUT_WIDE
    M__(M_out(L"<< =MOVE= >>   << =MOVE= >>   buffer_C& operator=(buffer_C&&) called -- move assignment -- sz=%s  sz1=%s  copy_ct=%u\"") % M_sep(sz) % M_sep(sz1) % copy_ct;)
#else
    M__(M_out( "<< =MOVE= >>   << =MOVE= >>   buffer_C& operator=(buffer_C&&) called -- move assignment -- sz=%s  sz1=%s  copy_ct=%u\"") % M_sep(sz) % M_sep(sz1) % copy_ct;)
#endif
        
    //  return immediately, if self-assignment

    if (this == &from)
        return *this    
   

    // replace this's  buffer pointers and counts by from's -- data automatically moves with the pointer/counter update  

    this->free();                                               // get rid of current buffer before switching pointers to from's buffer

    p         =   from.p       ;   
    p1        =   from.p1      ;  
    sz        =   from.sz      ;   
    sz1       =   from.sz1     ;   
    copy_ct   =   from.copy_ct ;   
    

    // clear out fields in from -- from's old buffer is now anchored in this

    from.sz  = 0ULL;              // data area in from has been moved out 
    from.sz1 = 0ULL;              // data area in from has been moved out 
    from.p   = nullptr;           // data area is now anchored off this
    from.p1  = nullptr; 
                        
    return *this; 
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  destructor -- free buffer, etc. 
//  ----------  
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
buffer_C<T>::~buffer_C()      
{
    M__(M_out(L"~buffer_c() called -- destructor -- sz=%s  sz1=%s  copy_ct=%u") % M_sep(sz) % M_sep(sz1) % copy_ct;)
    
    this->free();
    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  free() -- free buffer 
//  ------  
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
void buffer_C<T>::free()      
{
    M__(M_out(L"buffer_C::free() called -- sz=%s  sz1=%s") % M_sep(sz) % M_sep(sz1);)
    
    if (p1 != nullptr)
       delete[] p1; 
    
    sz  = 0; 
    sz1 = 0; 
    p   = nullptr; 
    p1  = nullptr;

    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  alloc() -- allocate buffer (free any existing buffer, first) 
//  -------  
//
//  note: input length parm is always in units of <T> 
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
void buffer_C<T>::alloc(uint64_t sz_in)      
{
    M__(M_out(L"buffer_C::alloc(%s) called -- sz=%s  sz1=%s") % M_sep(sz_in) % M_sep(sz) % M_sep(sz1);)
    
    this->free();

    if (sz_in > 0)
    {
        p1  = new uint8_t[sz_in * sizeof (T)];
        p  = (T *)p1; 
        sz  = sz_in; 
        sz1 = sz * sizeof (T);
    }
    
    return;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  alloc1() -- allocate buffer (free any existing buffer, first) 
//  -------  
//
//  note: input length parm is always in bytes
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
void buffer_C<T>::alloc1(uint64_t sz1_in)      
{
    M__(M_out("buffer_C::alloc1(%s) called -- sz=%s  sz1=%s") % M_sep(sz1_in) % M_sep(sz) % M_sep(sz1);)
    
    this->free();

    if (sz1_in > 0)
    {
        p1   = new uint8_t[sz1_in];
        p    = (T *)p1; 
        sz1  = sz1_in; 
        sz   = sz1 / sizeof (T);          // round sz down, as required
    }
    
    return;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  realloc() -- re-allocate buffer, if new requested size is larger than existing size 
//  ---------  
//
//  note: input length parm is always in units of <T> 
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
void buffer_C<T>::realloc(uint64_t sz_in)      
{
    M__(M_out("buffer_C::realloc(%s) called -- sz=%s  sz1=%s") % M_sep(sz_in) % M_sep(sz) % M_sep(sz1);)
    
    if (sz_in > sz)
       this->alloc(sz_in);        
    
    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  realloc1() -- re-allocate buffer, if new requested size is larger than existing size 
//  ----------  
//
//  note: input length parm is always in bytes 
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
void buffer_C<T>::realloc1(uint64_t sz1_in)      
{
    M__(M_out("buffer_C::realloc1(%s) called -- sz=%s  sz1=%s") % M_sep(sz1_in) % M_sep(sz) % M_sep(sz1);)
    
    if (sz1_in > sz1)
       this->alloc1(sz1_in);        
    
    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  clear() -- zero out entire buffer area (if any) 
//  -------  
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
void buffer_C<T>::clear()      
{
    M__(M_out("buffer_C::clear() called -- sz=%s  sz1=%s") % M_sep(sz) % M_sep(sz1);)
    
    if ( (sz1 > 0) && (p1 != nullptr) )
       ::memset((void *)p1, (char)0, (size_t)sz1);          
    
    return;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  assign1() -- assign all bytes in buffer to same value 
//  ---------  
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
void buffer_C<T>::assign1(char ch)      
{
    M__(M_out("buffer_C::assign1(%02X) called -- sz=%s  sz1=%s") % (uint32_t)ch % M_sep(sz) % M_sep(sz1);)
    
    if ( (sz1 > 0) && (p1 != nullptr) )
       ::memset((void *)p1, ch, (size_t)sz1);          
    
    return;
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////